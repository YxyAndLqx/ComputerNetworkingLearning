2020年2月19日：
	学习《计算机网络自顶向下方法》第三章
	运输层位于应用层和网络层之间，是分层的网络体系结构的重要部分
	3.1 概述和运输层服务
		1.运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信功能
		2.运输层只在端系统中实现
		3.运输层分组被称为运输层报文段
		4.重要事实：网络路由器仅作用于该数据报的网络层字段；即它们不检查封装在该数据报的运输层报文段的字段
		5.运输层协议不仅有TCP和UDP
	3.1.1 运输层和网络层的关系
		1.网络层提供主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供逻辑通信
		2.计算机网络中可以安排多种运输层协议，每种协议为应用程序提供不同的服务模型。
		3.运输层协议能够提供的服务常常受制于底层网络层协议的服务模型
		4.运输层协议也能为应用程序提供可靠的数据传输服务
	3.1.2 因特网运输层概述
		1.UDP（用户数据报协议），提供不可靠无连接服务；TCP（传输控制协议），提供可靠的、面向连接的服务
		2.有时也将TCP的运输层分组称为报文段，而常将UDP的分组称为数据报
		3.IP为主机之间提供逻辑通信。IP的的服务模型是“尽力而为的交付服务”所以被称为不可靠服务
		4.将主机间交付扩展到进程间交付被称为运输层的多路复用与多路分解
		5.UDP是一种不可靠服务
		6.TCP提供可靠数据传输，提供拥塞控制
		7.TCP通过流量速率调节使每个进程能平的地共享网络带宽资源，UDO的流量不可调节（用户可调节），使用UDP传输的应用程序可以根据其需要以其愿意的任何速率发送数据（很好的抢带宽特性）
	3.2 多路复用与多路分解
		1.将运输层报文段中的数据交付到正确套接字的工作称为多路分解
		2.在源主机从不同套接字中收集数据块，并为每个数据块封装部首信息从而生产报文段，然后将报文段传递到网络层，这些所有工作称为多路复用
		3.端口号是一个16比特的数，其大小在0~65535之间。0~1023为周知端口号
		4.一个UDP套接字由一个目的IP地址和一个目的端口号标识，两个有不同源端口号，源IP地址，相同目的端口号，目的IP地址的UDP报文将通过相同的目的套接字被定向到相同的目的进程。 
		5.TCP通过4元组（源端口号，源IP地址，目的端口号，目的IP地址）唯一标识一个套接字，与UDP不同的是，两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字。
2020-2-20：
	3.3无连接的传输：UDP
		1.UDP只是做了运输协议能够做的最少工作，除了复用/分解功能及少量的差错检测外，它几乎没有对IP增加别的东西
		2.使用UDP时，发送报文之前，发送方和接收方的运输层实体之间没有握手，所以UDP称为无连接的
		3.DNS是一个通常使用UDP的例子。
		4.TCP并不总是首选，UDP可以由应用层更精确地控制何时发送何种数据，UDP无需建立连接，没有连接时延。UDP无连接状态可以支持更多的活跃客户，UDP分组首部开销小
		5.TCP的拥塞控制会导致如因特网电话、视频会议之类的实时应用性能变得很差，所以多媒体应用通常使用UDP
		6.当分组丢包率低时，并且为了安全起见，某些机构阻塞UDP流量。
		7.UDP缺乏拥塞控制能够导致UDP发送方和接收方之间的高丢包率，并挤垮TCP会话，这是一个潜在的严重问题
		8.使用UDP的应用是可以实现可靠数据传输的。将可靠性直接构建于应用程序中可以使其“左右逢源”也就是说应用进程可以进行可靠通信，而无需受制于由TCP拥塞控制机制导致的传输速率限制。
	3.3.1 UDP报文结构
		+--------------------+--------------------+
		|      源端口号      |    目的端口号      |
		+--------------------+--------------------+
		|        长度        |     校验和         |
		+--------------------+--------------------+
		|                应用数据                 |
		|                （报文）                 |
		+-----------------------------------------+
		|_________________________________________|
						  32比特
		UDP首部只有4个字段：长度字段指首部加数据的长度，校验和用于接收方检查是否出现差错
	3.3.2 UDP校验和
	    1.对报文段中的所有16比特字的和进行反码运算，求和时遇到的任何溢出都回卷
		2.端到端原则：因为某种功能必须基于端到端实现：与在较高界别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余或几乎没有价值的。
	3.4 可靠数据传输原理
		1.TCP提供传输数据比特不会受到损害或丢失，而且所有数据都是按照其发送顺序进行交付的服务模型
		2.实现这种服务抽象是可靠数据传输协议的责任
	3.4.1 构造可靠数据传输协议
		1.有限状态机（FSM）
		2.ACK（肯定确认）
		3.NAK（否定确认）
		4.ACK和NAK控制报文是接收方可以让发送方知道哪些内容被正确接收，哪些内容接收有误需要重传。基于这种重传机制的可靠数据传输协议称为自动重传请求协议（ARQ）
		5.ARQ协议还需要差错检测，接收方反馈，重传
		6.发送一个报文等待回复再发送另一个报文的协议称为停等协议。
		7.报文中增加序号字段，接收方可以通过检查序号确定收到的分组是否是一次重传。
		8.确定丢包等待时间，发送方与接收方之间的往返时延，接受方处理一个分组的时间
		9.实践中，发送方等待一个时间，超时即重传，无论是否真的丢包
		10.分组的接受时间必定晚于发送时间
		11.因为分组序号在0和1之间交替，rdt3.0也被称为比特交替协议

	明天还需要仔细研究一下rdt3.0
2020-2-21：
	重看rdt3.0
	3.4.2 流水线可靠数据传输协议
		1.对于rdt3.0这样一个停等协议，在两个端系统之间传播时延RTT=30毫秒，通过一条发送速率R为1Gbps的信道传递分组，其信道利用率仅0.00027
		2.信道利用率：发送方实际忙于将发送比特送进信道的那部分时间与发送时间之比
		3.允许发送多个分组而无需等待确认的技术，称为流水线。
		4.需要为流水线技术增加序号范围
		5.协议的发送方和接收方两端也许必须缓存多个分组。发送方最低限度应当能缓存那些已经发送但是没有确认的分组
		6.所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏及延时过大的分组。
		7.解决流水线的差错恢复有两种基本方法，回退N步（GBN)和选择重传（SR）。
	3.4.3 回退N步
		1.回退N步协议，允许发送方发送多个分组而不需要等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N
		2.那些已被发送但还未被确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口。随着协议的运行，该窗口可以在序号空间向前滑动，所以N常被称为窗口长度，GBN协议也常被称为滑动窗口协议。
		3.GBN发送方必须响应三种类型的事件：
			>上层的调用
			>收到一个ACK。对序号为n的分组确认采用累积确认的方式，表明接收方已正确接收到序号为n的以前且包含n在内的所有分组
			>超时事件，超时后协议重传所有发送未确认的分组，回退n步的由来。
		4.接收方丢弃所有失序分组.
		5.这种方法的优点是接收缓存简单，接收方不需要缓存任何失序分组。
2020-2-22：
	3.4.4 选择重传
		1.GBN协议存在性能问题，尤其是当窗口长度和带宽时延积都很大的时候，单个分组的差错就能够引起GBN重传大量分组，许多分组根本没有必要重传。随着信道差错率的增加，流水线可能会被这些不必要的重传分组所充斥。
		2.选择重传（SR）协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免不必要的重传。
		+-----------------------------------------------------------------------------------------------------------+
		| 1.从上层接收收到数据，SR发送方检查下一个可用序号是否位于窗口内，如果是打包发送，否则缓存或返回上层        |
		| 2.超时，每一个分组都有一个定时器，可以通过一个硬件定时器模拟多个逻辑定时器实现                            |
		| 3.收到ACK，收到ACK，若序号还在窗口内，则标记为已发送，如果序号等于send_base，则窗口向前移动到未确认分组处 |
		+-----------------------------------------------------------------------------------------------------------+
		3.SR接收方将确认一个正确接收的分组而不管器是否按序，失序分组被缓存直到所有丢失的分组皆被收到为止。
		+-----------------------------------------------------------------------------------------------------------+
		| 1.序号在[rcv_base, rcv_base+N-1]内的分组被正确接收，一个选择ACK传回发送方，如果是未接收过的分组，就缓存， |
		|   若序号等于基序号，就向上交付连续的分组，窗口相应向前移动。                                              |
		| 2.收到小于基序号的分组，也发送ACK。                                                                       |
		| 3.其他情况，忽略该分组                                                                                    |
		+-----------------------------------------------------------------------------------------------------------+
		4.如果分组send_base的ACK没有从接收方传回发送方，则发送方将重传分组send_base,即使接收方已经收到该分组，如果接收方不确认该分组，则发送方窗口将永远不能向前滑动。
		5.发送方和接收方的窗口并不总是一致。
		6.当我们面临有限序号范围时，发送方和接收方窗口间缺乏同步将产生很严重的后果。
		7.对于SR协议而言，窗口长度必须小于或等于序号空间大小的一半。
		8.可靠数据传输协议的机制：
		+---------------------------------------------------------------------------------------------------------------------+
		| 1.检验和	         用于检测在一个传输分组中的比特错误                                                               | 
		| 2.定时器           用于超时/重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组延时但未丢失，或   |
		|					 当一个分组已被接收方收到但从接收方到发送方的ACK丢失时，可以产生超时事件，所以接收方可能会收到一  |
		|					 个分组的多个冗余副本。                                                                           |
		| 3.序号             用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可以使接收方检测出丢失的   |
		|                    分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本                                       |
		| 4.确认             接收方用于告诉发送方一个分组或一组分组已被正确接收到了。确认报文通常携带着被确认的分组或多个分组 |
		|                    的序号。确认可以是逐个的或累积的，这取决于协议                                                   |
        | 5.否定确认         接收方用于告诉发送方某个分组未被正确地接收。否定确认报文携带着未被正确接收的分组序号             |
		| 6.窗口、流水线     发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发   |
		|                    送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报 |
		|                    文的能力、网络中的拥塞程度或两者情况来进行设置                                                   |
		+---------------------------------------------------------------------------------------------------------------------+
		9.分组重新排序的表现就是：一个具有序号或确认号x的分组的旧副本可能会出现，即使发送方或接收方的窗口中没有包含x。
		10.实际应用中采用的方法是，确保一个序号不被重复使用，直到发送方确信任何先前发送的序号为x的分组都不再在网络中为止。
2020-2-23：
	3.5 面向连接的传输：TCP
		1.TCP是因特网传输层的面向连接的可靠的传输协议。
		2.TCP定义在RFC793、RFC1122、RFC 1323、RFC2018以及RFC2581中。
	3.5.1 TCP连接
		1.TCP发送数据之前，两个进程必须先相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。
		2.由于TCP协议只在端系统中运行，而不在中间网络元素中运行，所以中间的网络元素不会维持TCP连接状态。
		3.TCP连接提供的是全双工服务。
		4.TCP连接总是点对点的，对于TCP而言，两台主机是一对，而3台主机则太多。
		5.三次握手：客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个报文段作为响应。
		 前两个报文段不承载“有效载荷”第三个报文段可以承载有效载荷。
		6.TCP将待发送数据引导到发送缓存里，发送缓存是在三次握手初期设置的缓存之一。
		7.TCP可从缓存中取出并放入报文段中的数据数量受限于最大报文段长度（MSS）
		8.MSS通常根据最初确定的由本地发送的最大链路层帧长度（MTU）来设置。
		9.MSS要保证一个TCP报文段加上TCP/IP首部长度将适合单个链路层帧。
		10.MSS的典型值为1460字节。
		11.注意MSS是指在报文段中应用层数据的最大长度，而不是指包括TCP首部的TCP报文段的最大长度。
	3.5.2 TCP报文段结构
		|<-------------------------------------32比特----------------------------------->|
		+---------------------+----------------------------------------------------------+
		|                  源端口号               |               目的端口号             |
		+---------------------+----------------------------------------------------------+
		|                                        序号                                    |
		+--------------------------------------------------------------------------------+
		|                                       确认号                                   |
		+--------+--------+---+---+---+---+---+---+--------------------------------------+
		|首部长度|保留未用|URG|ACK|PSH|RST|SYN|FIN|                 接收窗口             |
		+-----------------------------------------+--------------------------------------+
		|               因特网校验和              |               紧急数据指针           |
		+-----------------------------------------+--------------------------------------+
		|                                       选项                                     |
		+--------------------------------------------------------------------------------+
		|                                       数据                                     |
		+--------------------------------------------------------------------------------+
		1.TCP报文首部一般20字节，而Telnet发送的报文段也许只有21字节长。
		2.TCP报文段也有源端口号，目的端口号，和校验和字段。
		3.32比特序号和32比特确认号字段。这些字段被TCP发送方和接收方用来实现可靠数据传输服务
		4.16比特的接收窗口字段，该字段用于流量控制。
		5.4比特的首部长度字段，由于TCP选项字段的原因，TCP首部长度是可变的。
		5.可选与变长的选项字段，该字段用于发送方与接收方协商最大报文长度时，或在高速网络环境下用作窗口调节因子使用。首部字段还有一个时间戳字段
		6.6比特的标志字段，ACK比特用于指示确认字段中的值是有效的，RST、SYN和FIN比特用于连接的建立和拆除，PSH比特被设置时指示接收方立即将数据交付给上层。
			URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”数据。紧急数据的最后一个字节由16比特的紧急数据指针字段指出。（实际中PSH和URG以及紧急数据
			指针并没有使用）
		7.报文序号是该报文段首字节的字节流编号。
		8.TCP只确认该流中至第一个丢失字节为止的字节，所以TCP又被称为提供累积确认
		9.接收方接收到失序报文，要么丢弃失序报文，要么保留失序字节等待缺少的字节填充间隔。TCP在实际中采用后者。
		10.从客户到服务器的数据的确认被装载在一个承载服务器到客户的数据的报文段中；这种确认时被称为被捎带在服务器到客户的数据报文段中的。
	3.5.3 往返时间的估计与超时
		1.往返时间（RTT）
		2.报文段的样本RTT就是从某报文段被发出到对该报文段的确认被收到之间的时间量。
		3.大多数TCP的实现仅在某个时刻做一次SampleRTT测量。
		4.TCP决不为已经被重传的报文段计算SampleRTT。
		5.由于路由器的拥塞和端系统的负载变化，报文段的SampleRTT值或随之波动。
		6.SampleRTT均值（EstimatedRTT）
		7.EstimatedRTT =（1-α）・EstimatedRTT+α・SampleRTT
		8.在[RFC6298]中给出的α参考值是α=0.125，所以：EstimatedRTT= 0.875・Estimated+α・SampleRTT
		9.在统计学中，这种平均被称为指数加权移动平均（EWMA）
		10.用DevRTT表征RTT的变化。
		11.DevRTT = (1-β)・DevRTT+β・|SampleRTT-EstimatedRTT|
		12.如果SampleRTT波动较小，那么DevRTT的值就会变小，反之变大。β推荐值0.25
		13.超时间隔：TimeoutInterval = EstimatedRTT + 4・DevRTT
		14.推荐的初试TimeoutInterval为1秒，出现超时后TimeoutInterval值会加倍。
2020-2-24：
	3.5.4 可靠数据传输
		1.TCP在IP不可靠的尽力而为的服务至上创建一种可靠数据传输服务
		2.由于定时器开销较大，因此，推荐的定时器管理过程[RFC 6298] 仅适用单一的重传定时器，即使有多个已发送但还未被确认的报文段。
		3.TCP发送方有三个与发送和重传有关的主要事件，TCP从应用程序接收数据；定时器超时和收到ACK。
		4.由于ACK丢失引起的重传数据会被接收端丢失。
		5.同时发送两个报文，第一个报文超时重传并重启定时，只要第二个报文段的ACK在新的超时发生之前到达，则第二个报文段将不会被重传。
		6.同时发送两个报文，第一个报文的ACK丢失，只要第二个报文的ACK在超时之前到达，发送方不会重传这两个报文中的任何一个。
		7.超时间隔加倍，会导致时间间隔在每次重传后呈指数级增长。但是定时器由收到上层数据或者收到ACK事件重启，TimeoutInterval由最近的EstimatedRTT值与DevRTT值推算得到。
		8.7中的修改提供了一种形式受限的拥塞控制。
		9.TCP不使用否定确认。
		10.比期望序号大的失序报文段到达。检测出间隔，立即发送冗余ACK，指示下一个期待字节的序号。
		11.一旦收到3个冗余ACK，TCP就执行快速重传，即在该报文段的定时器过时之前重传丢失的报文段。
		12.TCP更像GBN协议，但是TCP只重传ACK丢失的报文，如果n+1报文段ACK在n报文段超时之前到达，TCP不会重传任何报文段。
		13.对TCP提出的一种修改意见是所谓的选择确认[RFC2018],它允许TCP接收方有选择的确认失序报文段，而不是累积确认最后一个正确接收的有序报文段。
		14.TCP的差错恢复机制更像GBN协议与SR协议的混合体。
	3.5.5 流量控制
		1.TCP为它的应用程序提供流量控制服务，以消除发送方式接收方缓存溢出的可能性。
		2.TCP发送方有可能因为IP网络的拥塞而被遏制；这种形式的发送方的控制被称为拥塞控制。
		3.TCP通过让发送方维护一个接收窗口的变量来提供流量控制。
		4.LastByteRead：主机B上的应用进程从缓存读出的数据流的最后一个字节编号。
		5.LastByteRcvd：从网络中到达的并且已放入主机B接收缓存中的数据流的最后一个字节编号
		6.要使缓存不溢出，LastByteRcvd - LastByteRead <= RcvBuffer
		7.接收窗口rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]
		8.发送方在该连接的整个生命周期须保证：LastByteSent-LastByteAcked <= rwnd
		9.TCP规范要求，当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认，最终缓存将开始清空，并且确认报恩将包含一个非零的rwnd值。
		10.UDP不提供流量控制，如果进程从缓存区中读取报文段的速度不够快，那么缓存将会溢出。
2020-2-25：
	3.5.6 TCP连接管理
		1.TCP连接的建立会显著地增加人们感受到的时延。
		2.许多网络攻击，如SYN洪泛攻击，都会利用TCP连接管理的弱点。
		3.客户中的TCP会以以下方式与服务器中的TCP建立一条TCP连接
			第一步：客户端TCP首先向服务端TCP发送SYN标准位置1的SYN报文段，另外客户会随机选择一个初始序号，放置于该起始TCPSYN报文段的序号字段中。
			第二步：一旦TCP SYN报文段到达服务器主机，服务器会为该TCP连接分配缓存和变量，并向该客户TCP发送允许连接的报文段。该允许连接的报文段有时会被称为SYNACK报文段。
			第三步：收到SYNACK之后，客户也为这个连接分配缓存和变量。客户主机再想服务器发送一个报文段以确认（通过将server_isn+1填入报文的确认字段完成）。
		4.创建连接时，在两台主机之间发送了3个分组。所以连接建立的过程也叫做三次握手。
		5.参与到一条TCP连接的两个进程中的任意一个都可以终止该连接。
		6.在一个TCP连接的生命周期中运行在每台主机中的TCP协议在各种TCP状态之间迁移。
		7.SYN洪泛攻击：攻击者发送大量的TCPSYN报文段而不完成第三次握手的步骤，以消耗服务器的资源，造成拒绝服务攻击。
		8.SYN cookie可以防止洪泛攻击：
			1）当服务器收到一个SYN报文，不开半开连接，而是首先用源和目的端口号与IP地址以及秘密数计算一个初始TCP序列号，填入SYNACK中。
			2）当客户是合法的，它返回的确认ACK报文段将会填入初始序列号+1的值。服务器再计算这个报文的SYN coolie与其中的序列号比对。如果刚好是序列号-1则生成一个具有套接字的全开连接
			3）如果客户没有返回ACK报文段，则初始的SYNC并没有对服务器造成伤害。
		9.如果主机上的某一个端口并没有被使用，TCP收到访问这个端口的TCP报文时会将RST标志位置1。
		10.当一台主机接收一个UDP分组，它的目的端口与进行中的UDP套接字不匹配，该主机发送一个特殊的ICMP数据报。
		11.nmap检查某个端口是否开放时的做法，先向该端口发送一个TCPSYN：
			1）如果从目标主机收到一个TCP SYNACK报文段，意味着此端口打开
			2）如果收到TCP RST报文段说明，TCPSYN报文到达了目标主机，但是窗口没有开放
			3）如果什么都没有收到，则报文段可能被中间的防火墙拦截了。
		12.nmap可以还侦查多种信息，包括UDP端口，防火墙配置信息，甚至应用程序的版本和其操作系统。
2020-2-26：
	3.6 拥塞控制原理
		1.分组重传作为网络拥塞的征兆
		2.为了处理网络拥塞原因，需要一些机制以在面临网络拥塞时遏制发送方。
		3.异步传递（ATM），可用比特率（ABR）
	3.6.1 拥塞原因与代价
		1.情况1：两个发送方和一台具有无穷大的缓存的路由器。当发送速率接近R/2时，平均时延会越来越大。当发送速率超过R/2时，路由器中的平均排队分组就会无限增长，源与目的地之间的平均时延也会变得无穷大。
			当分组的到达速率接近链路容量时，分组经历巨大的排队时延。
		2.情况2：两个发送方和一台具有有限缓存的路由器，数据被交付给接收方应用程序的速率变为R/3，发送方必须执行重传以补偿因为缓存溢出而丢弃的分组。
			发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。
		3.情况3:4个发送方和具有有限缓存的多台路由器及多跳路径，当一个分组沿着一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。
	3.6.2 拥塞控制方法
		1.端到端拥塞控制。在这种方法中，网络层没有为运输层拥塞控制提供显示支持。
		2.TCP必须通过端到端的方法解决拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。
		3.TCP报文段的丢失被认为是网络拥塞的一个迹象，TCP会相应减小其窗口长度。
		4.网络辅助的拥塞控制。网络层构建向发送方提供关于网络中拥塞状态的显示反馈信息。
		5.关于源端是增加还是降低其传输速率，XCP协议对每个源提供路由器计算反馈，该反馈携带在分组首部中。
		6.直接反馈信息可以由网络路由器发送给发送方。这种放肆的通知通常采用阻塞分组的形式。
		7.经由接收方的网络反馈，路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。
	3.6.3 网络辅助的拥塞控制例子：ATM ABR拥塞控制
		1.ATM基本上采用一种面向虚电路（VC）的方法来处理分组交换。
		2.网络交换机上的这种逐VC状态是ATM非常适合执行网络辅助拥塞控制。
		3.当网络轻载时，ABR服务会充分利用空闲的可用带宽；当网络拥塞时，ABR服务会将其传输速率抑制为某些预先确定的最小传输速率。
		4.在数据信元中夹杂有所谓的资源管理信元；这些RM信元可被用来在主机和交换机之间传递与拥塞相关的信息。
		5.EFCI比特，每个数据信元都包含1比特的显式转发拥塞指示比特。
		6.CI和NI比特，RM信元中有拥塞指示比特和无增长比特
		7.ER字段，显式速率字段。
2020-2-27：
	3.7 TCP拥塞控制
		1.TCP的另一个关键部分就是其拥塞控制机制。
		2.TCP必须使用端到端拥塞控制而不是使用网络辅助的拥塞控制。
		3.TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量组成。
		4.运行在发送方的TCP拥塞控制机制跟踪一个额外变量，cwnd，拥塞窗口。
		5.在一个发送方中有：LastByteSent-LastByteAcked<=min{cwnd,rwnd}
		6.发送方大概速率是cwnd/RTT字节/秒
		7.将一个TCP发送方的“丢包事件”定义为：要么出现超时，要么收到来自接收方的3个冗余ACK。
		8.因为TCP使用确认来触发增大它的拥塞窗口长度，TCP被说成是自计时。
		9.一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。
		10.一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。
		11.带宽侦测，TCP调节其传输速率的策略是增加其速率以响应到达的ACK，除非出现丢包事件，此时才减少传输速率。
	慢启动：
		1.慢启动状态cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加1个MSS
		2.TCP发送速率起始慢，但是在慢启动阶段以指数增长。
		3.如果存在一个由超时指示的丢包事件，TCP发送方将cwnd设置为1并重新开始慢启动过程。
		4.ssthresh（慢启动阈值）在丢包事件后被设为cwnd/2。
		5.当cwnd的值等于ssthresh时，结束慢启动并且TCP转移到拥塞避免模式。
		6.最后一种结束慢启动的方式是，如果检测到3个冗余的ACK，这时TCP执行一种快速重传并进入快速恢复状态。
2020-2-28:
	拥塞避免
		1.一旦进入拥塞避免状态，cwnd值是上次遇到拥塞时的一半
		2.每个RTT只将cwnd的值增加一个MSS。
		3.当出现超时时，TCP也是将cwnd值设为1，而3个冗余ACK会。TCP将cwnd减半，ssthresh也设为cwnd的一半。
	快速恢复
		1.早期版本TCPTahoe不管是超时还是收到3个冗余ACK都将cwnd置为1个MSS。
		2.TCPReno综合了快速恢复
		3.忽略开始时的慢启动状态，假定丢包由3个冗余ACK而不是超时指示，TCP的拥塞控制是：每个RTT内cwnd线性增加1MSS，然后出现三个冗余ACK事件时cwnd减半。
			因此TCP拥塞控制常被称为加性增，乘性减拥塞控制方法（AIMD）。
		4.TCP Vegas算法在分组丢失发生之前，在源于目的地之间检测路由器中的拥塞；当检测出快要发生的分组丢失时，线性地降低发送速率。
		5.Linux支持多种拥塞控制算法，可以通过配置使用特定版本的TCP。默认为CUBIC算法。
		6.TCP AIMD算法基于大量的工程见解和运行网络中的拥塞控制经验而开发。
2020-2-29:
	对TCP吞吐量的宏观描述
		1.TCP发送数据的速率是拥塞窗口与当前RTT的函数，当窗口是w字节，且当前往返时间是RTT秒时，则TCP的发送速率大约是w/RTT。
		2.假设在连续持续期间RTT和W几乎不变，那么TCP的传输速率在W/(2xRTT)到W/RTT之间变化。
		3.一条连接的平均吞吐量=0.75xW/RTT
	经高带宽路径的TCP
		1.TCP拥塞控制已经演化很多年并仍在持续演化。
		2.以往对因特网有益的东西，不一定对当今HTTP主宰的因特网或具有难以想象的服务的未来因特网还是有益的。
		3.TCP连接的吞吐量公式，该公式作为丢包率（L)，往返时间（RTT）和最大报文段长度（MSS）的函数：一条连接的平均吞吐量=1.22xMSS/RTT√L
		4.为了取得10Gbps的吞吐量，今天的TCP拥塞控制算法仅能容忍2x10^-10的报文丢失概率。
	公平性
		5.所谓瓶颈链路就是对于每条连接，沿着该连接路径上的所有其他段链路都不拥塞，而且与该瓶颈链路的传输容量相比，它们都是充足的传输容量。
		6.如果每条连接的平均传输速率接近R/K，即每条连接都得到相同份额的链路带宽，则认为该拥塞控制机制是公平的。
		7公平性与UDP许多媒体应用经常因为特定原因不在TCP上运行，因为他们不想其传输速率被遏制，即使在网络拥塞的情况下。从TCP的观点来看，运行在UDP上的多媒体应用是不公平的。
		8.即使我们能迫使UDP流量具有公平的行为，但公平性问题仍然没有完全解决。这是因为我们无法阻止基于TCP的应用使用多个并行连接。